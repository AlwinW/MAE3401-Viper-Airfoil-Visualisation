# Turning Point
.[,tp.lag1 := lead(Udash,1) - Udash, by = c("surf", "xO")] %>%
.[,tp.sign1 := sign(tp.lag1 * lag(tp.lag1)), by = c("surf", "xO")] %>%
.[,tp.lag2 := tp.lag1 - lag(tp.lag1, 1), by = c("surf", "xO")] %>%
# UUm
.[,uum.diff := 1 - UUmdash, by = c("surf", "xO")] %>%
.[,uum.sign := sign(lead(uum.diff,1) * uum.diff), by = c("surf", "xO")] %>%
# Magintude of vel
.[,mag.vel := 1 - sqrt(Udash^2 + Vdash^2), by = c("surf", "xO")] %>%
.[,mag.sign := sign(lead(mag.vel,1) * mag.vel), by = c("surf", "xO")]
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[which.max(Udash)], by = c("surf", "xO")] %>%
.[, method := "max"]
blthicktp <- numericalmethod[tp.sign1 == -1 & tp.lag2 < 0, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "tp"]
blthickuum <- numericalmethod[uum.sign == -1, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "UUm"]
blthickmag <- numericalmethod[mag.sign == -1, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "mag"]
rm(numericalmethod)
blthickness = rbind(blthickmax, blthicktp, blthickuum, blthickmag) %>%
.[, method := factor(method, levels = methodlevels)] %>%
.[]
return(blthickness)
}
test1 = BLThickness(omesh, lvec)
test1[]
(test2)
BLThickness <- function(omesh, lvec, varnames = c("U", "V"),
methodlevels = c("theory", "max", "tp", "UUm", "mag")) {
# Interpolate
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
# Manipulate data.table
outcols = c("xO", "dist", "surf", "Udash", "Vdash", "UUmdash")
numericalmethod <- interpval[abs(Udash) >  1e-3, outcols, with = FALSE] %>%
# Order the data
# setorder(., surf, xO) %>%
# Turning Point
.[,tp.lag1 := lead(Udash,1) - Udash, by = c("surf", "xO")] %>%
.[,tp.sign1 := sign(tp.lag1 * lag(tp.lag1)), by = c("surf", "xO")] %>%
.[,tp.lag2 := tp.lag1 - lag(tp.lag1, 1), by = c("surf", "xO")] %>%
# UUm
.[,uum.diff := 1 - UUmdash, by = c("surf", "xO")] %>%
.[,uum.sign := sign(lead(uum.diff,1) * uum.diff), by = c("surf", "xO")] %>%
# Magintude of vel
.[,mag.vel := 1 - sqrt(Udash^2 + Vdash^2), by = c("surf", "xO")] %>%
.[,mag.sign := sign(lead(mag.vel,1) * mag.vel), by = c("surf", "xO")]
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[which.max(Udash)], by = c("surf", "xO")] %>%
.[, method := "max"]
blthicktp <- numericalmethod[tp.sign1 == -1 & tp.lag2 < 0, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "tp"]
blthickuum <- numericalmethod[uum.sign == -1, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "UUm"]
blthickmag <- numericalmethod[mag.sign == -1, outcols, with = FALSE] %>%
.[, .SD[which.min(dist)], by = c("surf", "xO")] %>%
.[, method := "mag"]
rm(numericalmethod)
blthickness = rbind(blthickmax, blthicktp, blthickuum, blthickmag) %>%
.[, method := factor(method, levels = methodlevels)] %>%
setorder(., surf, xO)
return(blthickness)
}
test1[]
test1 = BLThickness(omesh, lvec)
test1[]
(test2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Search along a smaller distance step
h2 = 2e-5
dist2 = seq(min(blthickness$dist) - h1, max(blthickness$dist)  + h1, by = h2)
dom <- as.matrix(sapply(blthickness$dist,
function(dist) dist2 > (dist - h1) & dist2 < (dist + h1)))
dom = apply(dom, 1, sum)
dom = ifelse(dom != 0, TRUE, FALSE)
dist2 = dist2[dom]
lvec <- NormalLvec(xvec, dist2, AoA, c("upper", "lower"))
rm(dist2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
blthickness
blthickness[]
interpval
interpval = cbind(rep(interpval, times = 4), method = rep(c("max", "tp", "UUm", "mag")))
interpval[]
rep(interpval, times = 4)
interpval = do.call("rbind", replicate(3, interpval, simplify = FALSE))
interpval[]
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
dist = seq(0, max(blthickness$dist), by = h)
h = 1e-4
dist = seq(0, max(blthickness$dist), by = h)
lvec <- NormalLvec(xvec, dist, AoA, c("upper", "lower"))
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
interpval = do.call("rbind", replicate(3, interpval, simplify = FALSE))
interpval[]
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
test = do.call("rbind", replicate(3, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), times = nrow(interpval))]
test = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), times = nrow(interpval))]
test]
test[]
test = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), each = nrow(interpval))]
test[]
?setkey
blthickness
test = integrand[blthickness]
nterpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
integrand = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), each = nrow(interpval))]
integrand = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), each = nrow(interpval))]
test
blthickness
integrand[]
thickness = blthickness[, c("surf", "xO", "method", "dist")]
thickness[]
thickness[,hello = dist]
thickness[, "hello" = dist]
thickness[, "hello" == dist]
thickness[, "hello" := dist]
thickness[]
thickness = blthickness[, "thickness" := dist][, c("surf", "xO", "method", "dist")][]
thickness[]
thickness = blthickness[, "thickness" := dist][, c("surf", "xO", "method", "thickness")]
thickness
test = integrand[blthickness, on = c("surf", "xO", "method")]
test[]
integrand = integrand[blthickness, on = c("surf", "xO", "method")]
integrand[]
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
integrand = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), each = nrow(interpval))]
# Reduce the blthickness data.table to be smaller
thickness = blthickness[, "thickness" := dist][, c("surf", "xO", "method", "thickness")]
integrand[]
object.size(integrand)
object.size(integrand)/1024^2
format(object.size(integrand), unit = "mb")
format(object.size(integrand), unit = "Mb")
test = integrand[blthickness, on = c("surf", "xO", "method")] %>%
# Filter only columns in the thickness
.[dist < thickness]
gc()
test[]
thickness = blthickness[, "thickness" := dist][, c("surf", "xO", "method", "thickness")]
thickness[]
testp[]
test[]
rm(interpval, thickness, integrand)
gc()
# Find the interpolation along the points of lvec
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
interpval = do.call("rbind", replicate(4, interpval, simplify = FALSE)) %>%
.[,method := rep(c("max", "tp", "UUm", "mag"), each = nrow(interpval))]
# format(object.size(integrand), unit = "Mb")
# Reduce the blthickness data.table to be smaller
thickness = blthickness[, "thickness" := dist][, c("surf", "xO", "method", "thickness")]
# Right Join with integrand
integrand = interpval[blthickness, on = c("surf", "xO", "method")] %>%
# Filter only columns in the thickness
.[dist < thickness]
integrand[]
integrand = interpval[thickness, on = c("surf", "xO", "method")] %>%
# Filter only columns in the thickness
.[dist < thickness]
integrand[]
#---------------------------->
#--- Run Post-processing on multi-threaded machine
#--- Alwin Wang MAE3401
#============================>
#--- Set the wd() if necessary ----
# setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# setwd("//ad.monash.edu/home/User032/awan39/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs")
#--- Load All the functions -----
source("Script All Functions.R")
#--- Load the Data in the Folder ----
# If using multiple computers set move = TRUE
temp = LoadFolder(foldername = "Input_Data", move = FALSE)
list2env(temp, envir = environment()); rm(temp)
#--- Load the AIrfoil Data ----
# Load the Airfoil
NACA = 4412
airfoildata <- LoadAirfoil(NACA, a = -0.5, c = 1)
#--- Location for Saving ----
saveplot = "Output_Plot"
savedata = "Output_Data"
if (!file.info(saveplot)$isdir) dir.create(saveplot, recursive = TRUE)
if (!file.info(savedata)$isdir) dir.create(savedata, recursive = TRUE)
logfile = paste0(format(Sys.time(), "%Y-%m-%dT%H.%M.%S"), ".txt")
#--- Thread Function ----
source("Script Threads.R")
source("Script All Functions.R")
source("Script Plots.R")
threadname <- ThreadName()
# Load the filedata and unlist it
filedata <- LoadFile(filename, foldername)
list2env(filedata, envir = environment()); # rm(filedata)       # N.B: local so must be passed as fn input
# >> File Data Loaded ----
ThreadProgress(threadname, Re, AoA, "File Data Loaded
---------------------------------------------------------------")
#--- Run Airfoil Calculations ----
list2env(airfoildata, envir = .GlobalEnv)                     # N.B: global so all fn can find it
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
filename = filelist[2]
source("Script All Functions.R")
source("Script Plots.R")
threadname <- ThreadName()
# Load the filedata and unlist it
filedata <- LoadFile(filename, foldername)
list2env(filedata, envir = environment()); # rm(filedata)       # N.B: local so must be passed as fn input
# >> File Data Loaded ----
ThreadProgress(threadname, Re, AoA, "File Data Loaded
---------------------------------------------------------------")
#--- Run Airfoil Calculations ----
list2env(airfoildata, envir = .GlobalEnv)                     # N.B: global so all fn can find it
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
xvec = AirfoilSamp(seq(a, a+c, by = 0.2), polyn = 5, cylinder = TRUE)
varnames = c("U", "V")
methodlevels = c("max", "tp", "UUm", "mag", "theory")
# Search using a distance step
h1 = 0.01
dist1 = NormalSamp(seq(0, 18, by = h1))
lvec <- NormalLvec(xvec, dist1, AoA, c("upper", "lower"))
rm(dist1)
outcols = c("xO", "dist", "surf", "Udash", "Vdash", "UUmdash")
interpval <- data.table(InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE))
numericalmethod <- interpval[abs(Udash) >  1e-3, outcols, with = FALSE] %>%
# Order the data
# setorder(., surf, xO) %>%
# Turning Point
.[,tp.lag1 := lead(Udash,1) - Udash, by = c("surf", "xO")] %>%
.[,tp.sign1 := sign(tp.lag1 * lag(tp.lag1)), by = c("surf", "xO")] %>%
.[,tp.lag2 := tp.lag1 - lag(tp.lag1, 1), by = c("surf", "xO")] %>%
# UUm
.[,uum.diff := 1 - UUmdash, by = c("surf", "xO")] %>%
.[,uum.sign := sign(lead(uum.diff,1) * uum.diff), by = c("surf", "xO")] %>%
# Magintude of vel
.[,mag.vel := 1 - sqrt(Udash^2 + Vdash^2), by = c("surf", "xO")] %>%
.[,mag.sign := sign(lead(mag.vel,1) * mag.vel), by = c("surf", "xO")]
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[which.max(Udash)-1, which.max(Udash), which.max(Udash) + 1], by = c("surf", "xO")] %>%
.[, method := "max"]
blthickmax
blthickmax[]
?data.table
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[c(which.max(Udash)-1, which.max(Udash), which.max(Udash) + 1)], by = c("surf", "xO")] %>%
.[, method := "max"]
blthickmax[]
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[(which.max(Udash)-1):(which.max(Udash) + 1)], by = c("surf", "xO")] %>%
.[, method := "max"]
blthickmax[]
?shift
?split
asdf <- split(blthickmax, xO)
asdf <- split(blthickmax, "xO")
asdf
asdf <- split(blthickmax, by = "xO")
asdf
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[(which.max(Udash)-1):(which.max(Udash) + 1)], by = c("surf", "xO")] %>%
.[, method := "max"]
split(blthickmax, by = c("surf", "xO"))
TP <- function(x, y) {
numerator = x[1]^2*(y[2]-y[3]) + x[3]^2*(y[1]-y[2]) + x[2]^2*(y[3]-y[1])
denominator = x[3]*(y[2]-y[1]) + x[2]*(y[1]-y[3]) + x[1]*(y[3]-y[2])
xtp = -1/2 * numerator/denominator
}
sapply(split(blthickmax, by = c("surf", "xO")),
function(points) {
do.call(TP, points[c("dist", "Udash")])
}
)
blthickmax <- numericalmethod[, outcols, with = FALSE] %>%
.[, .SD[(which.max(Udash)-1):(which.max(Udash) + 1)], by = c("surf", "xO")] %>%
.[, method := "max"]
sapply(split(blthickmax, by = c("surf", "xO")),
function(points) {
do.call(TP, points[c("dist", "Udash")])
}
)
sapply(split(blthickmax, by = c("surf", "xO")),
function(points) {
test = do.call(TP, points[c("dist", "Udash")])
print(test)
}
)
class(asdf)
class(asdf[[[1]]])
class(asdf[[1]])
split(blthickmax, by = list("surf", "xO")
)
split(blthickmax, by = list("surf", "xO"))
split(blthickmax, by = list(surf, xO))
split(blthickmax, by = c("surf", "xO"))
split(blthickmax, by = c("surf", "xO"), drop = TRUE)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
# test = do.call(TP, points[c("dist", "Udash")])
# print(test)
print(points$dist)
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
# test = do.call(TP, points[c("dist", "Udash")])
# print(test)
print(points$dist)
TP(points$dist, points$Udash)
}
)
blthickmax[]
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
return(data.table(xtp = xtp, skew = skew))
}
)
TP <- function(x, y) {
numerator = x[1]^2*(y[2]-y[3]) + x[3]^2*(y[1]-y[2]) + x[2]^2*(y[3]-y[1])
denominator = x[3]*(y[2]-y[1]) + x[2]*(y[1]-y[3]) + x[1]*(y[3]-y[2])
xtp = -1/2 * numerator/denominator
if(is.na(xtp)) xtp = x[2]
return(xtp)
}
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
return(data.table(xtp = xtp, xmid =points$dist[2], x = skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, x = skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
# xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, x = skew = skew))
}
)
TP <- function(x, y) {
numerator = x[1]^2*(y[2]-y[3]) + x[3]^2*(y[1]-y[2]) + x[2]^2*(y[3]-y[1])
denominator = x[3]*(y[2]-y[1]) + x[2]*(y[1]-y[3]) + x[1]*(y[3]-y[2])
xtp = -1/2 * numerator/denominator
if(is.na(xtp)) xtp = x[2]
return(xtp)
}
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
# xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, x = skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
return(data.table(xtp = xtp, skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
return(data.table(xtp = xtp, skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, skew = skew))
}
)
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, skew = skew))
}
)
blvals = BLCalcs(omesh, xvec, AoA, Re)
BLThickness <- function(omesh, lvec, varnames = c("U", "V"),
methodlevels = c("max", "tp", "UUm", "mag", "theory")) {
# Find the interpolation along the points of lvec
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
#--- 100% Boundary Layer Thickness ----
# Manipulate the data to find the boundary layer thickness
interpval <- interpval %>%
# Remove potentially problematic flow at the wall %>%
filter(abs(Udash) > 1e-3) %>%
# Turning Point
mutate(tp.lag1 = lead(Udash, 1) - Udash) %>%
mutate(tp.sign1 = sign(tp.lag1 * lag(tp.lag1)),
tp.lag2 = tp.lag1 - lag(tp.lag1, 1)) %>%
# UUm
mutate(uum.diff = 1 - UUmdash) %>%
mutate(uum.sign = sign(lead(uum.diff,1) * uum.diff)) %>%
# Magintude of vel
mutate(mag.vel = 1 - sqrt(Udash^2 + Vdash^2)) %>%
mutate(mag.sign = sign(lead(mag.vel,1) * mag.vel))
# Using the max thickness
blthickmax <- interpval %>%
select(xO, dist, surf, Udash, UUmdash) %>%
slice(which.max(Udash)) %>%
mutate(method = "max")
# Using the turning point
blthicktp <- interpval %>%
filter(tp.sign1 == -1, tp.lag2 < 0) %>%
select(xO, dist, surf, Udash, UUmdash) %>%
slice(which.min(dist))%>%
mutate(method = "tp")
# Using Uum equal to 1
blthickuum <- interpval %>%
filter(uum.sign == -1) %>%
select(xO, dist, surf, Udash, UUmdash) %>%
slice(which.min(dist))%>%
mutate(method = "UUm")
# Using the magnitude of the velocity
blthickmag <- interpval %>%
filter(mag.sign == -1) %>%
select(xO, dist, surf, Udash, UUmdash) %>%
slice(which.min(dist))%>%
mutate(method = "mag")
# Remove the object to conserve RAM
rm(interpval)
# Output of thicknesses (100%)
blthickness = rbind(blthickmax, blthicktp, blthickuum, blthickmag) %>%
mutate(method = factor(method, levels = methodlevels)) %>%
group_by(method, add = TRUE) %>%
arrange(surf, xO, method)
return(blthickness)
}
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, skew = skew))
}
)
blvals = BLCalcs(omesh, xvec, AoA, Re)
blvals
sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, skew = skew))
}
)
filter(blvals, method = "max")
filter(blvals, method == "max")
varnames = c("U", "V")
methodlevels = c("max", "tp", "UUm", "mag", "theory")
testTP <- sapply(split(blthickmax, by = c("surf", "xO"), drop = TRUE),
function(points) {
xtp = TP(points$dist, points$Udash)
skew = points$dist[2] - mean(points$dist)
xmid = points$dist[2]
return(data.table(xtp = xtp, xmid = xmid, skew = skew))
}
)
testTP
# NOTE: Combine into BL Calc Laterz
# Search using a distance step
h1 = 0.01
dist1 = NormalSamp(seq(0, 18, by = h1))
lvec <- NormalLvec(xvec, dist1, AoA, c("upper", "lower"))
rm(dist1)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Search along a smaller distance step
h2 = 2e-5
dist2 = seq(min(blthickness$dist) - h1, max(blthickness$dist)  + h1, by = h2)
dom <- as.matrix(sapply(blthickness$dist,
function(dist) dist2 > (dist - h1) & dist2 < (dist + h1)))
dom = apply(dom, 1, sum)
dom = ifelse(dom != 0, TRUE, FALSE)
dist2 = dist2[dom]
lvec <- NormalLvec(xvec, dist2, AoA, c("upper", "lower"))
rm(dist2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
blthickness
testTP
filter(blthickness, method == "max")
