blvals = BLValues(omesh, lvec, blthickness)
blvals
blvals3
xvec = xvec[xvec > a & xvec < a + c]
blval4 = blval
blvals4 = blvals
xvec
h1 = 0.01
dist1 = NormalSamp(seq(0, 18, by = h1))
lvec <- NormalLvec(xvec, dist1, AoA, c("upper", "lower"))
rm(dist1)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Search along a smaller distance step
h2 = 2e-5
dist2 = seq(min(blthickness$dist) - h1, max(blthickness$dist)  + h1, by = h2)
dom <- as.matrix(sapply(blthickness$dist,
function(dist) dist2 > (dist - h1) & dist2 < (dist + h1)))
dom = apply(dom, 1, sum)
dom = ifelse(dom != 0, TRUE, FALSE)
dist2 = dist2[dom]
lvec <- NormalLvec(xvec, dist2, AoA, c("upper", "lower"))
rm(dist2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Determine BL Thickness values
h = 1e-4
length.out = round(max(blthickness$dist)/h)
length.out = length.out + (4 - length.out%% 3)
dist = seq(0, max(blthickness$dist), length.out = length.out)
lvec <- NormalLvec(xvec, dist, AoA, c("upper", "lower"))
rm(dist)
blvals = BLValues(omesh, lvec, blthickness)
blvals
blval4
blvals4
blvals
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
xvec = xvec[xvec > a & xvec < a + c]
# Determine the points for the theoretical distances
lvec <-suppressWarnings(
lvec <- bind_rows(pblapply(surf,
function(surfval) {
bind_rows(lapply(xvec,
function(x) {
dist = 5 * (x - a) / sqrt(Re * (x - a))
NormalPoint(x, dist, AoA, surf = surfval)
}))
})))
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
BLValues <- function(omesh, lvec, blthickness, varnames = c("U", "V")) {
# Find the interpolation along the points of lvec
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xp, yp, xO, dist, surf, Udash, Vdash, UUmdash)
#--- Determine the distances ----
blvals = list()
for (i in 1:nrow(blthickness)) {
# print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) != 1) {
# HANDLES EXCEPTION WHERE SOLUTION NOT FOUND, i.e. h too big!!
# blvals[[i]] <- data.frame(
#   xO = blthickness$xO[i], dist = NA, surf = blthickness$surf[i], Udash = NA, Vdash = NA, UUmdash = NA,
#   thickness = NA, dispthick = NA, momethick = NA, kinethick = NA,
#   method = blthickness$method[i])
next
}
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
# distances <- (
#   apply(integrand, 2, sum) -
#     1/2 * integrand[1,] -
#     1/2 * integrand[nrow(integrand),]) *
#   soln$dist/(nrow(integrand)/2)
# Using 3/8 rule
n = nrow(integrand)
h = soln$dist/n
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = n),], 2, sum) -
1 * integrand[1,] -
1 * integrand[n,]) *
h
blvals[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
blvals = bind_rows(blvals)
return(blvals)
}
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xp, yp, xO, dist, surf, Udash, Vdash, UUmdash)
interpval
plot(interpval$xp, interpval$yp)
blvals
interpval
blvals
o
BLTheory <- function(xvec, AoA, Re, varnames = c("U", "V"), surf = c("upper", "lower")) {
# Remove x values from a cylindrical approximation
xvec = xvec[xvec > a & xvec < a + c]
# Determine the points for the theoretical distances
lvec <-suppressWarnings(
lvec <- bind_rows(pblapply(surf,
function(surfval) {
bind_rows(lapply(xvec,
function(x) {
dist = 5 * (x - a) / sqrt(Re * (x - a))
NormalPoint(x, dist, AoA, surf = surfval)
}))
})))
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xp, yp, xO, dist, surf, Udash, Vdash, UUmdash)
bltheory = data.frame(
interpval, thickness = interpval$dist, method =  "theory"
)
}
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Serial Debugging.R', echo=TRUE)
blvals = BLCalcs(omesh, xvec, AoA, Re)
bltheory = BLTheory(xvec, AoA, Re)
blvals
bltheory
blplot = rbind(blvals, bltheory)
blvals_old = blvals
7 % 2
7 \ 2
7 %/% 2
1 %/% 3
-1 %/% 3
(1:10 + 1) %/% 3
(1:10 - 1) %/% 3
n = 10
n38 = (n - 1) %/% 3
ntr = (n - 1) %% 3
n38
ntr
1:(3*n38 + 1)
x = 1:10
test = 1:10
integrand(data.frame(para = test^2, cubic = test^3, quartic = test^4))
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4)
integrand
n = nrow(integrand)
h = soln$dist/n     # NOTE: Clearly the input lvec must have had an equally spaced lvec
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
integrand38 = integrand[1:np38]
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38 + 1):(np38 + ntr)]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
}
distances = distances38 + distancestr
distances
distances = distances38
distances
test = 1:10
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38 + 1):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
distances
test = -5:20
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38 + 1):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
print(distances)
test = 1:10
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38 + 1):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
print(distances)
test = 1:11
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38 + 1):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
print(distances)
integrandtr
test = 1:11
integrand = data.frame(para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
print(distances)
integrandtr
test = 1:11
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[nptr,])
distances = distances + distancestr
}
print(distances)
integrandtr
distances38
distancestr
2 * apply(integrandtr, 2, sum)
integrandtr[1,]
integrandtr[nptr,]
n = nrow(integrand)
h = soln$dist/n     # NOTE: Clearly the input lvec must have had an equally spaced lvec
test = 1:11
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[(np38 + ntr),])
distances = distances + distancestr
}
print(distances)
test = 1:11
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[(np38 + ntr),])
distances = distances + distancestr
}
print(distances)
integrandtr[ntr,]
integrandtr[1,]
test = 1:11
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[ntr + 1,])
distances = distances + distancestr
}
print(distances)
test = 1:12
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[ntr + 1,])
distances = distances + distancestr
}
print(distances)
test = seq(1, 12, length.out = 100)
integrand = data.frame(lin = test, para = test^2, cubic = test^3, quartic = test^4, sin = sin(test))
n = nrow(integrand)
print(n)
h = test[2] - test[1]
n38 = (n - 1) %/% 3 # Number of 3/8 rules to be applied
ntr = (n - 1) %% 3  # Number of trap rules to be applied (at the end)
print(n38)
print(ntr)
# 3/8 Rule
np38 = (3*n38 + 1)  # Number of points in the integrand for 3/8
integrand38 = integrand[1:np38,]
distances38 = 3/8 * h *
(3 * apply(integrand38, 2, sum) -
apply(integrand38[rep(c(TRUE, FALSE, FALSE), length.out = n38),], 2, sum) -
integrand38[1,] -
integrand38[np38,])
distances = distances38
# Trap Rule
nptr = ntr
if (nptr != 0) {
integrandtr = integrand[(np38):(np38 + ntr),]
distancestr = 1/2 * h *
(2 * apply(integrandtr, 2, sum) -
integrandtr[1,] -
integrandtr[ntr + 1,])
distances = distances + distancestr
}
print(distances)
