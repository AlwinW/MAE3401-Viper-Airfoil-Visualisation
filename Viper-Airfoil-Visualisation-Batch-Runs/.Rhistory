kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
} else {
integrand = data.frame(
dispthick = 0, momethick = 0, kinethick = 0)
}
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
i
i = 4
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
} else {
integrand = data.frame(
dispthick = 0, momethick = 0, kinethick = 0)
}
i = 5
blvalues = list()
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
} else {
integrand = data.frame(
dispthick = 0, momethick = 0, kinethick = 0)
}
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
i = 3
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
} else {
integrand = data.frame(
dispthick = 0, momethick = 0, kinethick = 0)
}
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
} else {
integrand = data.frame(
dispthick = 0, momethick = 0, kinethick = 0)
}
integrand
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
distances
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Serial Debugging.R', echo=TRUE)
# NOTE: Combine into BL Calc Laterz
# Search using a distance step
h1 = 0.01
dist1 = NormalSamp(seq(0, 18, by = h1))
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist1, AoA = AoA, surf = surfval))))
rm(dist1)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Search along a smaller distance step
h2 = 2e-5
dist2 = seq(min(blthickness$dist) - h1, max(blthickness$dist)  + h1, by = h2)
dom <- as.matrix(sapply(blthickness$dist,
function(dist) dist2 > (dist - h1) & dist2 < (dist + h1)))
dom = apply(dom, 1, sum)
dom = ifelse(dom != 0, TRUE, FALSE)
dist2 = dist2[dom]
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist2, AoA = AoA, surf = surfval))))
rm(dist2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Determine BL Thickness values
h = 1e-3
length.out = round(max(blthickness$dist)/h)
length.out = length.out + (4 - length.out%% 3)
dist = seq(0, max(blthickness$dist), length.out = length.out)
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = surfval))))
rm(dist)
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
varnames = c("U", "V")
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
blvalues = list()
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
} else {
distances = data.frame(
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps)
}
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
blvalues = bind_rows(blvalues)
blvalues = BLValues(omesh, lvec, blthickness)
blvals = BLCalcs(omesh, xvec, AoA, Re)
#--- Load Packages ----
source("Function Load Packages.R")      # For required packages
#--- Print Progress ----
source("Function pblapply.R")           # For PrintThreadProgress
threadname <- ThreadName()
#--- Load ALL file information  ----
source("Function Load Data.R")          # For fn "Load File"
# Load the filedata and unlist it
filedata <- LoadFile(filename, foldername)
list2env(filedata, envir = environment()); rm(filedata)       # N.B: local so must be passed as fn input
ThreadProgress(threadname, Re, AoA, "File Data Loaded")
#--- Run Airfoil Calculations ----
source("Function Airfoil Profile.R")    # For fn "AirfoilCoord", etc
list2env(airfoildata, envir = .GlobalEnv)                     # N.B: global so all fn can find it
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
ThreadProgress(threadname, Re, AoA, "Airfoil Coordinates Calculated")
#--- Interpolation on the airfoil----
source("Function Interpolations.R")     # For fn "InterpPoint", etc
airfoilsurfmesh <- InterpPoint(omesh, airfoilcoord, varnames = c("P", "vort_xy_plane"))
ThreadProgress(threadname, Re, AoA, "Airfoil Surface Interpolation Calculated")
#--- Interpolation on Normals ----
source("Function Airfoil Normals.R")    # For "AirfoilGrads", etc
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = TRUE)
dist = NormalSamp(seq(0, 1.5, by = 0.05))
# Find the combined lvec for
lvec <- NormalLvec(xvec, dist, AoA, c("upper", "lower"))
interpval <- InterpProj(omesh, lvec, plotsurf = TRUE)
# SAVE INTERPVAL then delete it!
ThreadProgress(threadname, Re, AoA, "Interpolation on Normals to Surface Calculated")
#--- Boundary Layer Calculations ----
source("Function Boundary Layers.R")
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = TRUE)
blvals = BLCalcs(omesh, xvec, AoA, Re)
ThreadProgress(threadname, Re, AoA, "Boundary Layers Calculated")
# #--- Velocity Profile Calculations ----
space.usage <- sort(sapply(ls(), function(x) format(object.size(get(x)), units = "auto")))
i
# NOTE: Combine into BL Calc Laterz
# Search using a distance step
h1 = 0.01
dist1 = NormalSamp(seq(0, 18, by = h1))
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist1, AoA = AoA, surf = surfval))))
rm(dist1)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Search along a smaller distance step
h2 = 2e-5
dist2 = seq(min(blthickness$dist) - h1, max(blthickness$dist)  + h1, by = h2)
dom <- as.matrix(sapply(blthickness$dist,
function(dist) dist2 > (dist - h1) & dist2 < (dist + h1)))
dom = apply(dom, 1, sum)
dom = ifelse(dom != 0, TRUE, FALSE)
dist2 = dist2[dom]
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist2, AoA = AoA, surf = surfval))))
rm(dist2)
blthickness = BLThickness(omesh, lvec)
rm(lvec)
# Determine BL Thickness values
h = 1e-3
length.out = round(max(blthickness$dist)/h)
length.out = length.out + (4 - length.out%% 3)
dist = seq(0, max(blthickness$dist), length.out = length.out)
lvec <- bind_rows(pblapply(
c("upper", "lower"),
function(surfval) bind_rows(lapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = surfval))))
rm(dist)
blvalues = BLValues(omesh, lvec, blthickness)
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
blvalues = list()
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
} else {
distances = data.frame(
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps)
}
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
i = 3
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
soln
if (length(soln$dist) == 1) {
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
} else {
distances = data.frame(
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps)
}
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
soln
?next
blvalues = list()
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) != 1) {
# HANDLES EXCEPTION WHERE SOLUTION NOT FOUND, i.e.
blvalues[[i]] <- data.frame(
xO = 0, dist = 0, surf = 0, Udash = 0, Vdash = 0, UUmdash = 0,
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps,
blthickness$method[i])
next
}
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
blvalues = bind_rows(blvalues)
blthickness
blvalues = list()
for (i in 1:nrow(blthickness)) {
print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) != 1) {
# HANDLES EXCEPTION WHERE SOLUTION NOT FOUND, i.e.
blvalues[[i]] <- data.frame(
xO = blthickness$xO[i], dist = 0, surf = blthickness$surf[i], Udash = 0, Vdash = 0, UUmdash = 0,
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps,
blthickness$method[i])
next
}
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
blvalues = bind_rows(blvalues)
View(blvalues)
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
blvalues = list()
for (i in 1:nrow(blthickness)) {
# print(i)
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
if (length(soln$dist) != 1) {
# HANDLES EXCEPTION WHERE SOLUTION NOT FOUND, i.e. h too big!!
blvalues[[i]] <- data.frame(
xO = blthickness$xO[i], dist = 0, surf = blthickness$surf[i], Udash = 0, Vdash = 0, UUmdash = 0,
dispthick = .Machine$double.eps, momethick = .Machine$double.eps, kinethick = .Machine$double.eps,
method = blthickness$method[i])
next
}
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
# REPLACE with a 3/8 rule!
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/(nrow(integrand)/2)
blvalues[[i]] <- cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i])
}
blvalues = bind_rows(blvalues)
blvalues
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
blvalues
blvalues = BLValues(omesh, lvec, blthickness)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Serial Debugging.R', echo=TRUE)
blvals = BLCalcs(omesh, xvec, AoA, Re)
stopCluster(cl)
stopCluster(cl)
blvalues
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Serial Debugging.R', echo=TRUE)
blvalues
blvalues blvals
blvalues = blvals
rm(blvals)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Boundary Layers.R', echo=TRUE)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Serial Debugging.R', echo=TRUE)
blvalues
dist = 5 * xvec / sqrt(Re)
lvec <- NormalLvec(xvec, dist2, AoA, c("upper", "lower"))
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
dist = 5 * xvec / sqrt(Re)
lvec <- NormalLvec(xvec, dist, AoA, c("upper", "lower"))
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
BLValues
varnames = c("U", "V")
dist = 5 * xvec / sqrt(Re)
lvec <- NormalLvec(xvec, dist, AoA, c("upper", "lower"))
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
interpval
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Interpolations.R', echo=TRUE)
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
interpval
dist = 5 * xvec / sqrt(Re)
dist
lvec = NormalPoint(xvec, dist, AoA, surf = "upper")
