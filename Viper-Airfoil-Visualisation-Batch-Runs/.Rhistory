colnames(interpvar) <- var
return(interpvar)
}
)
lmesh
lmesh <- lvec
for (var in varnames) {
lmeshv <- suppressWarnings(
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap)))
lmesh <- cbind(lmesh, lmeshv[3])
}
# Give the columns meaningful names
colnames(lmesh) <- c(colnames(lvec), varnames)
lmesh
# Loop through each variable to interpolate
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
lmesh
InterpPoint0<- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
lmesh <- lvec
for (var in varnames) {
lmeshv <- suppressWarnings(
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap)))
lmesh <- cbind(lmesh, lmeshv[3])
}
# Give the columns meaningful names
colnames(lmesh) <- c(colnames(lvec), varnames)
return(lmesh)
}
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
# Return output
return(lmesh)
}
InterpPoint(omesh, lvec)
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
suppressWarnings(
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
# Return output
return(lmesh)
}
system.time(test1 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
# Interpoint Speed testing
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
# Interpoint Speed testing
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 100), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 1000), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
1 + 2
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 1000), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvectet = list(rep(lvec, 10))
lvectet
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
lvectest = list(rep(lvec, 10))
lvectest
?rep
lvectest = list(rep(lvec, times = 10))
lvectest
test0
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
lvectest = list(rep(lvec, 10))
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
?sapply
speedtest <- function() {
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
}
lvectest = list()
for (i = 1:50) {
lvectest[[i]] = lvec
}
lvectest = list()
for (i in 1:50) {
lvectest[[i]] = lvec
}
lvectest
system.time(test0 <- lapply(lvectest, function(lvec) InterpPoint0(omesh, lvec)))
system.time(test1 <- lapply(lvectest, function(lvec) InterpPoint(omesh, lvec)))
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
suppressWarnings(
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
})
)
# Append these interpolations to the original data
lmesh <- bind_cols(lvec, lmesh)
# Return output
return(lmesh)
}
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
stopCluster(parallelCluster)
LoadPackages()
test = 1:11
test
test[rep(c(1, 0, 0), length.out = length.out)]
test[rep(c(1, 0, 0), length.out = 11)]
test[rep(c(TRUE, FALSE, FALSE), length.out = 11)]
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out)], 2, sum) -
1 * integrand[1,] -
1 * integrand[2,]) *
thickness/length.out
length.out = 50
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out)], 2, sum) -
1 * integrand[1,] -
1 * integrand[2,]) *
thickness/length.out
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
1 * integrand[1,] -
1 * integrand[2,]) *
thickness/length.out
distances
3 * apply(integrand, 2, sum)
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum)
rep(c(TRUE, FALSE, FALSE), length.out = length.out)
integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),]
integrand
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
integrand
interp
length.out
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
dist
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
lvec
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
load("C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Working_Data/SingleThreadTest2.RData")
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Boundary Layers.R', echo=TRUE)
#--- Required files ----
source("Function Install Packages.R")
LoadPackages()
source("Plot Settings.R")
savepath = "Output_Data"
source("Function Airfoil Profile.R")
source("Function Airfoil Normals.R")
source("Function Interpolations.R")
source("Function Boundary Layers.R")
#--- Manipulate input data ----
# Expand the airfoil data into the current thread environment
list2env(airfoildata, envir = .GlobalEnv)
#--- Airfoil profile and plot ----
# Airfoil coordinates
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
xO = -0.2
surf = "upper"
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
InterpProj <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Interpolate  to find the varibles
lmesh <- InterpPoint(omesh, lvec, varnames, linear, extrap)
# Use vector projection parallel to the normal
lmesh <- lmesh %>%
mutate(surf = ifelse(surf == "upper" & dely > 0, "upper", "lower")) %>%
mutate(surf = ifelse(surf == "lower" & dely < 0, "lower", "upper")) %>%
# Udash and Vdash found by using vector projections
mutate(Udash = sqrt((U - (delx*U + dely*V)/dist^2 * delx)^2 + (V - (delx*U + dely*V)/dist^2 * dely)^2),
Vdash = (delx*U + dely*V)/dist) %>%
mutate(Udash = ifelse(dist != 0, Udash, 0),
Vdash = ifelse(dist != 0, Vdash, 0)) %>%
# sign of Udash found by cross product, upper vs lower
mutate(Udash = sign(dely*U - delx*V) * ifelse(surf == "upper", 1, -1) * Udash)
# print(paste(lmesh$dist, lmesh$Udash))
return(lmesh)
}
length.out = 50
length.out = length.out + (4 - length.out%% 3)
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
integrand
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
1 * integrand[1,] -
1 * integrand[2,]) *
thickness/length.out
distances
integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),]
xO = -0.2
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
BLIntegrals <- function(omesh, xO, thickness, blU, surf, AoA, gradint = gradint, length.out = 2e5) {
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
1 * integrand[1,] -
1 * integrand[length.out,]) *
thickness/length.out
return(distances)
}
xO = -0.2
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0.4
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
BLIntegrals <- function(omesh, xO, thickness, blU, surf, AoA, gradint = gradint, length.out = 2e5) {
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
# Using 3/8 rule
# distances <- 3/8* (
#   3 * apply(integrand, 2, sum) -
#   apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
#   1 * integrand[1,] -
#   1 * integrand[length.out,]) *
#   thickness/length.out
# Using 1/2 rule
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[length.out]) *
thickness/length.out
return(distances)
}
xO = -0.2
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
BLIntegrals <- function(omesh, xO, thickness, blU, surf, AoA, gradint = gradint, length.out = 2e5) {
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
# Using 3/8 rule
# distances <- 3/8* (
#   3 * apply(integrand, 2, sum) -
#   apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
#   1 * integrand[1,] -
#   1 * integrand[length.out,]) *
#   thickness/length.out
# Using 1/2 rule
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[length.out,]) *
thickness/length.out
return(distances)
}
xO = -0.2
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0.4
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
BLIntegrals <- function(omesh, xO, thickness, blU, surf, AoA, gradint = gradint, length.out = 2e5) {
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
# Using 3/8 rule
distances <- 3/8* (
3 * apply(integrand, 2, sum) -
apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
1 * integrand[1,] -
1 * integrand[length.out,]) *
thickness/length.out
# # Using 1/2 rule
# distances <- (
#   apply(integrand, 2, sum) -
#   1/2 * integrand[1,] -
#   1/2 * integrand[length.out,]) *
#   thickness/length.out
return(distances)
}
xO = -0.2
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
xO = 0.4
gradint <- AirfoilGrads(xO, surf = surf)
blthickness <- BLThickOptim(omesh, xO, surf = surf, AoA, gradint = gradint)
thickness = blthickness$thickness
blU = blthickness$blU
system.time(blintegrals <- BLIntegrals(omesh, xO, thickness, blU, surf = surf, AoA, gradint = gradint))
blintegrals
BLIntegrals <- function(omesh, xO, thickness, blU, surf, AoA, gradint = gradint, length.out = 2e5) {
# Use Simpson's 3/8 Rule
length.out = length.out + (4 - length.out%% 3)
# Interpolate
dist = seq(0, thickness, length.out = length.out)
lvec = NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp = InterpProj(omesh, lvec, varnames = c("U", "V"))
# Find the integrands
integrand <- interp %>%
mutate(dispthick = 1 - Udash/blU,
momethick = Udash/blU * (1 - Udash / blU),
kinethick = Udash/blU * (1 - (Udash / blU)^2)) %>%
select(dispthick, momethick, kinethick)
# # Using 3/8 rule
# distances <- 3/8* (
#   3 * apply(integrand, 2, sum) -
#   apply(integrand[rep(c(TRUE, FALSE, FALSE), length.out = length.out),], 2, sum) -
#   1 * integrand[1,] -
#   1 * integrand[length.out,]) *
#   thickness/length.out
# Using trapezium rule
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[length.out,]) *
thickness/length.out
return(distances)
}
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Boundary Layers.R', echo=TRUE)
