function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE
)
uniroot(function(x) (x + 1)*(x - 1), interval = c(-2, 2))
?uniroot
optimise(function(x) (x-1)*(x-2)*(x-3), c(0,4))
optimise(function(x) (x-1)*(x-2)*(x-3)^2, c(0,4))
optimise(function(x) (x-1)*(x-2)*(x-3)^2, c(0,4), maximum = TRUE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0,4), maximum = TRUE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0,4), maximum = FALSE)
optimise(function(x) (x-1)^2*(x-3)^2, c(2,4), maximum = FALSE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0.99,4), maximum = FALSE)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
result
system.time(
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = result$maximum- abs(result$maximum)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
})
)
rm(result)
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
blU = blresult$maximum - abs(blresult$maximum)*0.01
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$objective))
blresult
result
blU
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
thickness
# Determine the gradient at xO
gradint <- AirfoilGrads(xO, surf = surf)
# Find the maximum value for U'
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
print(paste(dist, interp$Udash))
paste(dist, interp$Udash)
print(dist)
paste("hi", interp$Udash)
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, interp$Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
blu - result$minimum
blU - result$minimum
result$minimum
blu = result$minimum
blU = result$minimum
blU
rm(blu)
#
BLThickOptim <- function(omesh, xO, surf, AoA) {
# Determine the gradient at xO
gradint <- AirfoilGrads(xO, surf = surf)
# Find the maximum value for U'
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, interp$Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
blU = result$minimum
}
system.time(BLThickOptim(omesh, 0, "upper", AoA))
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Interpolations.R', echo=TRUE)
acos(0.3)
lmesh
InterpProj <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Interpolate  to find the varibles
lmesh <- InterpPoint(omesh, lvec, varnames, linear, extrap)
# Use vector projection parallel to the normal
lmesh <- lmesh %>%
# Udash and Vdash found by using vector projections
mutate(Udash = sqrt((U - (delx*U + dely*V)/dist^2 * delx)^2 + (V - (delx*U + dely*V)/dist^2 * dely)^2),
Vdash = (delx*U + dely*V)/dist) %>%
mutate(Udash = ifelse(dist != 0, Udash, 0),
Vdash = ifelse(dist != 0, Vdash, 0)) %>%
# sign of Udash found by cross product
mutate(Udash = ifelse(delx*V - dely*U > 0) * ifelse(surf == "upper", 1, -1) * Udash)
}
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
stopCluster(parallelCluster)
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
stopCluster(parallelCluster)
lmesh
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
stopCluster(parallelCluster)
NormalPoint(seq(0, 18, by = 0.01))
NormalPoint(seq(0, 18, by = 0.01), -0.2)
NormalPoint(-0.2, seq(0, 18, by = 0.01))
LoadPackages()
NormalPoint(-0.2, seq(0, 18, by = 0.01))
NormalPoint(-0.2, seq(0, 18, by = 0.01), AoA, "upper")
levec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
?lapply
levec = NormalPoint(-0.2, seq(0, 18, length.out = 3), AoA, "upper")
lmesh <- lapply(
varnames,
interpp,
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap
)
lmesh
bind_cols(lmesh)
bind_rows(lmesh)
lmesh <- lapply(
varnames,
function(var) {
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
}
)
lmesh
lvec
levec = NormalPoint(-0.2, seq(0, 18, length.out = 3), AoA, "upper")
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 3), AoA, "upper")
lvec
lmesh <- lapply(
varnames,
interpp,
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap
)
lmesh
lmesh <- lapply(
varnames,
function(var) {
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
}
)
lmesh
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
colnames(interpvar) <- c(colnames(lvec[1:2]), var)
}
)
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
colnames(interpvar) <- c(colnames(lvec[1:2]), var)
return(interpvar)
}
)
lmesh
bind_rows(lmesh)
bind_cols(lmesh)
?bind_rows
left_join(lmesh)
lvec
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
lmesh
lmesh <- lvec
for (var in varnames) {
lmeshv <- suppressWarnings(
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap)))
lmesh <- cbind(lmesh, lmeshv[3])
}
# Give the columns meaningful names
colnames(lmesh) <- c(colnames(lvec), varnames)
lmesh
# Loop through each variable to interpolate
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
lmesh
InterpPoint0<- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
lmesh <- lvec
for (var in varnames) {
lmeshv <- suppressWarnings(
as.data.frame(interpp(x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap)))
lmesh <- cbind(lmesh, lmeshv[3])
}
# Give the columns meaningful names
colnames(lmesh) <- c(colnames(lvec), varnames)
return(lmesh)
}
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
# Return output
return(lmesh)
}
InterpPoint(omesh, lvec)
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
suppressWarnings(
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
}
)
)
# Append these interpolations to the original data
lmesh <- cbind(lvec, bind_cols(lmesh))
# Return output
return(lmesh)
}
system.time(test1 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
# Interpoint Speed testing
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
# Interpoint Speed testing
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 100), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 1000), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
1 + 2
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 1000), AoA, "upper")
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
lvectet = list(rep(lvec, 10))
lvectet
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
lvectest = list(rep(lvec, 10))
lvectest
?rep
lvectest = list(rep(lvec, times = 10))
lvectest
test0
lvec = NormalPoint(-0.2, seq(0, 18, length.out = 10), AoA, "upper")
lvectest = list(rep(lvec, 10))
system.time(test0 <- InterpPoint0(omesh, lvec))
system.time(test1 <- InterpPoint(omesh, lvec))
?sapply
speedtest <- function() {
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
}
lvectest = list()
for (i = 1:50) {
lvectest[[i]] = lvec
}
lvectest = list()
for (i in 1:50) {
lvectest[[i]] = lvec
}
lvectest
system.time(test0 <- lapply(lvectest, function(lvec) InterpPoint0(omesh, lvec)))
system.time(test1 <- lapply(lvectest, function(lvec) InterpPoint(omesh, lvec)))
InterpPoint <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Loop through each variable to interpolate
suppressWarnings(
lmesh <- lapply(
varnames,
function(var) {
interpvar <- as.data.frame(interpp(
x = omesh$x, y = omesh$y, z = omesh[[var]],
xo = lvec[[1]], yo = lvec[[2]],
linear = linear,
extrap = extrap))
interpvar <- interpvar[3]
colnames(interpvar) <- var
return(interpvar)
})
)
# Append these interpolations to the original data
lmesh <- bind_cols(lvec, lmesh)
# Return output
return(lmesh)
}
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
stopCluster(parallelCluster)
