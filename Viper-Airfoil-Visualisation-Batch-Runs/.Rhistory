cl <- makeCluster(detectCores(), outfile = logfile)               # start the cluster
clusterExport(cl, c("airfoildata", "foldername", "logfile"))      # add airfoildata to the cluster threads
#--- Thread calculation ----
thread <- pblapplycl( #pbapply::pblapply( #
filelist,
function(filename) {                      # filename = filelist[1] for debugging
#--- Load Packages ----
source("Function Load Packages.R")      # For required packages
#--- Print Progress ----
source("Function pblapply.R")           # For PrintThreadProgress
threadname <- ThreadName()
#--- Load ALL file information  ----
source("Function Load Data.R")          # For fn "Load File"
# Load the filedata and unlist it
filedata <- LoadFile(filename, foldername)
list2env(filedata, envir = environment()); rm(filedata)       # N.B: local so must be passed as fn input
ThreadProgress(threadname, Re, AoA, "File Data Loaded")
#--- Run Airfoil Calculations ----
source("Function Airfoil Profile.R")    # For fn "AirfoilCoord", etc
list2env(airfoildata, envir = .GlobalEnv)                     # N.B: global so all fn can find it
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
ThreadProgress(threadname, Re, AoA, "Airfoil Coordinates Calculated")
#--- Interpolation on the airfoil----
source("Function Interpolations.R")     # For fn "InterpPoint", etc
airfoilsurfmesh <- InterpPoint(omesh, airfoilcoord, varnames = c("P", "vort_xy_plane"))
ThreadProgress(threadname, Re, AoA, "Airfoil Surface Interpolation Calculated")
#--- Interpolation on Normals ----
source("Function Airfoil Normals.R")    # For "AirfoilGrads", etc
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = TRUE)
dist = NormalSamp(seq(0, 1.5, by = 0.05))
# Find the combined lvec for
lvec <- rbind(
bind_rows(pblapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(pblapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
interpval <- InterpProj(omesh, lvec, plotsurf = TRUE)
# SAVE INTERPVAL then delete it!
ThreadProgress(threadname, Re, AoA, "Interpolation on Normals to Surface Calculated")
#--- Boundary Layer Calculations ----
source("Function Boundary Layers.R")
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = FALSE)
stopCluster(cl)
source("Function Load Packages.R")
# Note: Write out which folder(s) have been run and read them to determine which folder/s need to be run
# Alternavtively, you can have a list of which files have been run (more messy?)
# Or, you can automatically move the files out of the folder and then read them (more complicated!)
# AND order the list!
foldername = "Input_Data"
filelist <- list.files(foldername, pattern = "*.dat")
# Load the Airfoil
source("Function Load Data.R")
NACA = 4412
airfoildata <- LoadAirfoil(NACA, a = -0.5, c = 1)
# Load the pblapply wrapper to use (for progress bar)
source("Function pblapply.R")
#--- Initialise the cluster ----
logfile = paste0(format(Sys.time(), "%Y-%m-%dT%H.%M.%S"), ".txt") # logfile
filename = filelist[1]
#--- Load Packages ----
source("Function Load Packages.R")      # For required packages
#--- Print Progress ----
source("Function pblapply.R")           # For PrintThreadProgress
threadname <- ThreadName()
#--- Load ALL file information  ----
source("Function Load Data.R")          # For fn "Load File"
# Load the filedata and unlist it
filedata <- LoadFile(filename, foldername)
list2env(filedata, envir = environment()); rm(filedata)       # N.B: local so must be passed as fn input
ThreadProgress(threadname, Re, AoA, "File Data Loaded")
#--- Run Airfoil Calculations ----
source("Function Airfoil Profile.R")    # For fn "AirfoilCoord", etc
list2env(airfoildata, envir = .GlobalEnv)                     # N.B: global so all fn can find it
airfoilcoord <- AirfoilCoord(a, c + a, AoA, res = 100)
ThreadProgress(threadname, Re, AoA, "Airfoil Coordinates Calculated")
#--- Interpolation on the airfoil----
source("Function Interpolations.R")     # For fn "InterpPoint", etc
airfoilsurfmesh <- InterpPoint(omesh, airfoilcoord, varnames = c("P", "vort_xy_plane"))
ThreadProgress(threadname, Re, AoA, "Airfoil Surface Interpolation Calculated")
#--- Interpolation on Normals ----
source("Function Airfoil Normals.R")    # For "AirfoilGrads", etc
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = TRUE)
dist = NormalSamp(seq(0, 1.5, by = 0.05))
# Find the combined lvec for
lvec <- rbind(
bind_rows(pblapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(pblapply(xvec, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
interpval <- InterpProj(omesh, lvec, plotsurf = TRUE)
# SAVE INTERPVAL then delete it!
ThreadProgress(threadname, Re, AoA, "Interpolation on Normals to Surface Calculated")
#--- Boundary Layer Calculations ----
source("Function Boundary Layers.R")
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = FALSE)
min = 0; max = 18; l = 1e4
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = NormalSamp(seq(min, max, length.out = l)), AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
x = xvec[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = NormalSamp(seq(min, max, length.out = l)), AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
dist = lapply(blthickness$dist,
function(dist) seq(dist - h, dist + h, length.out = 1e3))
dist = sort(unlist(dist))
lvec = rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
h = dist[2] - dist[1]
rm(dist, lvec, blthickness)
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e4))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Refine the search
dist = lapply(blthickness$dist,
function(dist) seq(dist - h, dist + h, length.out = 1e3))
dist = sort(unlist(dist))
lvec = rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
rm(dist, lvec, blthickness)
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e4))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Refine the search
dist = lapply(blthickness$dist,
function(dist) seq(dist - h, dist + h, length.out = 1e4/nrow(blthickness)))
dist = sort(unlist(dist))
lvec = rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
head(dist)
varnames = c("U", "V")
interpval <- InterpProj(omesh, lvec, varnames = varnames, plotsurf = FALSE) %>%
select(xO, dist, surf, Udash, Vdash, UUmdash)
#--- Determine the distances ----
blvalues = data.frame()
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
blvalues <- rbind(cbind(soln, method = blthickness$method))
}
blvalues
setwd("//ad.monash.edu/home/User032/awan39/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs")
setwd("//ad.monash.edu/home/User032/awan39/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs")
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("Function Load Packages.R")
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
blvalues <- rbind(cbind(soln, distances, method = blthickness$method))
}
blvalues
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
blvalues <- rbind(cbind(soln, distances, method = blthickness$method))
}
blvalues
blthickness
blthickness$dist[i]
blvalues = data.frame()
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
print(distances)
blvalues <- rbind(cbind(soln, distances, method = blthickness$method))
}
blvalues
blvalues = data.frame()
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
print(distances)
blvalues <- rbind(blvalues, cbind(soln, distances, method = blthickness$method))
}
blvalues
blvalues = data.frame()
for (i in 1:length(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
blvalues <- rbind(blvalues, cbind(soln, distances, method = blthickness$method[i]))
}
return(blvalues)
blvalues
blthickness
blvalues = data.frame()
for (i in 1:nrow(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dist, dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
blvalues <- rbind(blvalues, cbind(soln, distances, method = blthickness$method[i]))
}
blvalues
blvalues = data.frame()
for (i in 1:nrow(blthickness)) {
soln <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= blthickness$dist[i],
Udash < blthickness$Udash[i] * 0.99) %>%
slice(which.max(dist))
integrand <- interpval %>%
ungroup() %>%
filter(xO == blthickness$xO[i],
surf == blthickness$surf[i],
dist <= soln$dist) %>%
mutate(Ur = Udash / soln$Udash,
dispthick = 1 - Ur,
momethick = Ur * (1 - Ur),
kinethick = Ur * (1 - (Ur)^2)) %>%
select(dispthick, momethick, kinethick)
distances <- (
apply(integrand, 2, sum) -
1/2 * integrand[1,] -
1/2 * integrand[nrow(integrand),]) *
soln$dist/nrow(integrand)
blvalues <- rbind(blvalues, cbind(
soln, thickness = soln$dist, distances, method = blthickness$method[i]))
}
blvalues
bl <- pblapply(xvec,
function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
}
)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Boundary Layers.R', echo=TRUE)
source("Function Boundary Layers.R")
xvec = AirfoilSamp(seq(a, a+c, by = 0.5), cylinder = FALSE)
bl <- pblapply(xvec,
function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
}
)
blvalues
bl
xvec = c(-0.2, 0, 0.4)
bl <- pblapply(xvec,
function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
}
)
bl
asdf <- function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
interpval <- InterpProj(omesh, lvec, plotsurf = FALSE)
#-------
blvalU <- pblapply(xvec, function(x) {
blval = BLCalcs(omesh, x, surf = "upper", AoA, Re)
return(blval)
})
blvalL <- pblapply(xvec, function(x) {
blval = BLCalcs(omesh, x, surf = "lower", AoA, Re)
return(blval)
})
blvalLong <- bind_rows(c(blvalU, blvalL))
ThreadProgress(threadname, Re, AoA, "Boundary Layers Calculated")
space.usage <- sort(sapply(ls(), function(x) format(object.size(get(x)), units = "auto")))
return(paste(ID, "Completed"))
},
cl = cl,
log = logfile
asdf <- function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
interpval <- InterpProj(omesh, lvec, plotsurf = FALSE)
#-------
blvalU <- pblapply(xvec, function(x) {
blval = BLCalcs(omesh, x, surf = "upper", AoA, Re)
return(blval)
})
blvalL <- pblapply(xvec, function(x) {
blval = BLCalcs(omesh, x, surf = "lower", AoA, Re)
return(blval)
})
blvalLong <- bind_rows(c(blvalU, blvalL))
ThreadProgress(threadname, Re, AoA, "Boundary Layers Calculated")
space.usage <- sort(sapply(ls(), function(x) format(object.size(get(x)), units = "auto")))
return(paste(ID, "Completed"))
},
cl = cl,
log = logfile
asdf(xvec)
asdf <- function (x) {
# NOTE: Combine into BL Calc Laterz
# Search along all normals to get 100% thickness
dist = NormalSamp(seq(0, 18, length.out = 1e6))
h = dist[2] - dist[1]
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blthickness = BLThickness(omesh, lvec)
# Determine BL values
dist = seq(0, max(blthickness$dist), length.out = 1e6)
lvec <- rbind(
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "upper")),
bind_rows(lapply(x, NormalPoint, dist = dist, AoA = AoA, surf = "lower")))
blvalues = BLValues(omesh, lvec, blthickness)
return(blvalues)
}
asdf(xvec)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Boundary Layers.R', echo=TRUE)
system.time(asdf(xvec))
system.time(aaaa <- asdf(xvec))
aaaa
object.size(aaaa)
xvec = AirfoilSamp(seq(a, a+c, by = 0.1), cylinder = FALSE)
source("Function Boundary Layers.R")
system.time(aaaa <- asdf(xvec))
space.usage <- sort(sapply(ls(), function(x) format(object.size(get(x)), units = "auto")))
space.usage
