geom_point(data = filter(interpval, Udash > 1.2), aes(x = x, y = y, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
ggplot () +
geom_point(data = interpval, aes(x = x, y = y, colour = Udash)) +
geom_point(data = filter(interpval, Udash < -1.2), aes(x = x, y = y, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpval, Udash > 1.2), aes(x = x, y = y, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
interpval
interpval <- pblapply(xvec, function(x) {
# Find the interpolations
lvec = NormalPoint(x, dist, surf = "upper")
interp <- InterpProj(omesh, lvec)
return(interp)
})
interpvalLong <- do.call("rbind", interpval)
ggplot () +
geom_point(data = interpvalLong, aes(x = x, y = y, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = x, y = y, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = x, y = y, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
ggplot () +
geom_point(data = interpvalLong, aes(x = x, y = y, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = x, y = y, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = x, y = y, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
# xlim(-1.2, 0.8) +
# ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
interpvalLong
ggplot () +
geom_point(data = interpvalLong, aes(x = xp, y = yp, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = xp, y = yp, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = xp, y = yp, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
# xlim(-1.2, 0.8) +
# ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
ggplot () +
geom_point(data = interpvalLong, aes(x = xp, y = yp, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = xp, y = yp, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = xp, y = yp, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
#--- Interpolation on Normals
xvec = AirfoilSamp(seq(a, a+c, by = 0.1), cylinder = TRUE)
dist = NormalSamp(seq(0, 1, by = 0.1))
interpval <- pblapply(xvec, function(x) {
# Find the interpolations
lvec = NormalPoint(x, dist, surf = "upper")
interp <- InterpProj(omesh, lvec)
return(interp)
})
interpvalLong <- bind_rows(interpval)
ggplot () +
geom_point(data = interpvalLong, aes(x = xp, y = yp, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = xp, y = yp, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = xp, y = yp, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
?lappy
?lapply
#--- Interpolation on Normals
xvec = AirfoilSamp(seq(a, a+c, by = 0.1), cylinder = TRUE)
dist = NormalSamp(seq(0, 0.8, by = 0.1))
interpvalU <- pblapply(xvec, function(x) {
# Find the interpolations
lvec = NormalPoint(x, dist, surf = "upper")
interp <- InterpProj(omesh, lvec)
return(interp)
})
interpvalL <- pblapply(xvec, function(x) {
# Find the interpolations
lvec = NormalPoint(x, dist, surf = "lower")
interp <- InterpProj(omesh, lvec)
return(interp)
})
interpvalLong <- bind_rows(c(interpvalU, interpvalL))
interpvalLong
ggplot () +
geom_point(data = interpvalLong, aes(x = xp, y = yp, colour = Udash)) +
geom_point(data = filter(interpvalLong, Udash < -1.2), aes(x = xp, y = yp, colour = Udash), colour = "#BE2828") +
geom_point(data = filter(interpvalLong, Udash > 1.2), aes(x = xp, y = yp, colour = Udash), colour = "#3C4BA0") +
geom_path(data = airfoilcoord, aes(x = x, y = y), size = 1.2) +
xlim(-1.2, 0.8) +
ylim(-0.8, 0.8) +
scale_colour_gradientn("U'", colours = brewer.pal(11, "RdYlBu"), limits = c(-1.2, 1.2)) +
coord_fixed()
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
NormalPoint
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
?optim
optim(0, function(x) x^2)
optim(0, function(x) -(x-5)^2)
optim(0, function(x) (x-5)^2)
optim(0, function(x) (x-5)^2, abstol = 1e-6)
optim(0, function(x) (x-5)^2, control = (abstol = 1e-6))
fr <- function(x) {   ## Rosenbrock Banana function
x1 <- x[1]
x2 <- x[2]
100 * (x2 - x1 * x1)^2 + (1 - x1)^2
}
plot(-10:10, fr(-10:10))
optim(c(-1.2,1), fr)
optim(0, function(x) (par[1]-5)^2, control = (abstol = 1e-6))
optim(0, function(x, par) (par[1]-5)^2)
optim(0, function(par) (par[1]-5)^2)
optim(0, function(par) (par[1]-5)^2 + 1)
optim(0, function(par) (par[1]-5)^2 + 1, control = (abstol = 0.0001))
?optimize
optimise(function(x) (x - 5)^2, lower = 0, upper = 10)
optimise(function(x) (x - 3)*(x - 7), lower = 0, upper = 10)
optimise(function(x) (x - 3)*(x - 7), lower = 0, upper = 10, maximum = TRUE)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
gradint = NULL
gradint <- ifelse(is.null(gradint), AirfoilGrads(xO, surf = surf), gradint)
gradint
unlist(gradint)
gradint[[1]]
AirfoilGrads(xO, surf = surf)
AirfoilGrads <- function(xO, surf = "upper", del = c*1e-8, out = "all") {
# Determine which geometry to use: airfoil or cylinder
out <- ifelse(xO < a,
AirfoilGradCyl(xO, surf, del),
AirfoilGradNACA(xO, surf, del))
return(out)
}
gradint <- ifelse(is.null(gradint), AirfoilGrads(xO, surf = surf), gradint)
gradint
gradint <- NULL
gradint
gradint <- ifelse(is.null(gradint), AirfoilGrads(xO, surf = surf), gradint)
gradint
unlist(gradint)
gradint
gradint <- ifelse(is.null(gradint), AirfoilGrads(xO, surf = surf), gradint)
gradint
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
xO
surf
AoA
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
}
)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
},
interval = c(0,18)
)
gradint <- AirfoilGrads(xO, surf = surf)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
},
interval = c(0,18)
)
stopCluster(parallelCluster)
stopCluster(parallelCluster)
stopCluster(parallelCluster)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
},
interval = c(0,18)
)
NormalPoint <- function(xO, dist, AoA = 0, surf = "upper", eq = "norm", gradint = NULL) {
# Find the gradient at the xO point
gradint <- ifelse(is.null(gradint), AirfoilGrads(xO, surf = surf), gradint)
gradint <- gradint[[1]]
# Note in AirfoilGrads it rootfinds for x already
# Determine the location of (xp, yp) for a given distance
gradint <- gradint %>%
filter(surf == get("surf") & eq == get("eq")) %>%
cbind(xO, ., dist) %>%
mutate(xdist = sign(m) * dist/sqrt(1+m^2) * ifelse(surf=="upper",1,-1)) %>%
mutate(xp = x + xdist,
yp = y + xdist * m)
# Transform the (xp, yp) and (x, y) coordinates and find the vector normal to the surface
lvec <- cbind(
AoATransform(distinct(gradint[c("xp", "yp")]), AoA),
AoATransform(distinct(gradint[c("x", "y")]), AoA),
gradint[c("xO", "dist", "surf", "eq")]
) %>%
mutate(delx = xp - x, dely = yp - y)
return(lvec)
}
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
},
interval = c(0,18)
)
gradint <- AirfoilGrads(xO, surf = surf)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE
)
.Machine$double.eps^0.25
dist = 1
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
lvec
interp <- InterpProj(omesh, lvec)
interp
rm(dist)
gradint <- AirfoilGrads(xO, surf = surf)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec)
print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE
)
gradint <- AirfoilGrads(xO, surf = surf)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U"))
print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE
)
gradint <- AirfoilGrads(xO, surf = surf)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE
)
uniroot(function(x) (x + 1)*(x - 1), interval = c(-2, 2))
?uniroot
optimise(function(x) (x-1)*(x-2)*(x-3), c(0,4))
optimise(function(x) (x-1)*(x-2)*(x-3)^2, c(0,4))
optimise(function(x) (x-1)*(x-2)*(x-3)^2, c(0,4), maximum = TRUE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0,4), maximum = TRUE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0,4), maximum = FALSE)
optimise(function(x) (x-1)^2*(x-3)^2, c(2,4), maximum = FALSE)
optimise(function(x) (x-1)^2*(x-3)^2, c(0.99,4), maximum = FALSE)
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
result
system.time(
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = result$maximum- abs(result$maximum)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
})
)
rm(result)
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
blU = blresult$maximum - abs(blresult$maximum)*0.01
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$objective))
blresult
result
blU
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
thickness
# Determine the gradient at xO
gradint <- AirfoilGrads(xO, surf = surf)
# Find the maximum value for U'
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
print(paste(dist, interp$Udash))
paste(dist, interp$Udash)
print(dist)
paste("hi", interp$Udash)
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, interp$Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
blu - result$minimum
blU - result$minimum
result$minimum
blu = result$minimum
blU = result$minimum
blU
rm(blu)
#
BLThickOptim <- function(omesh, xO, surf, AoA) {
# Determine the gradient at xO
gradint <- AirfoilGrads(xO, surf = surf)
# Find the maximum value for U'
blresult <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
# print(interp$Udash)
return(interp$Udash)
},
interval = c(0,18),
maximum = TRUE)
# Determine the 99% Um value
blU = blresult$objective - abs(blresult$objective)*0.01
# Find the distance for 99%
result <- optimise(
function(dist) {
lvec <- NormalPoint(xO, dist, AoA, surf, gradint = gradint)
interp <- InterpProj(omesh, lvec, varnames = c("U", "V"))
print(paste(dist, interp$Udash))
return(abs(interp$Udash - blU))
},
interval = c(0, blresult$maximum),
maximum = FALSE)
# Summarise results
thickness = result$objective
blU = result$minimum
}
system.time(BLThickOptim(omesh, 0, "upper", AoA))
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Function Interpolations.R', echo=TRUE)
acos(0.3)
lmesh
InterpProj <- function(omesh, lvec, varnames = c("U", "V", "P", "vort_xy_plane"),
linear = TRUE, extrap = FALSE) {
# Interpolate  to find the varibles
lmesh <- InterpPoint(omesh, lvec, varnames, linear, extrap)
# Use vector projection parallel to the normal
lmesh <- lmesh %>%
# Udash and Vdash found by using vector projections
mutate(Udash = sqrt((U - (delx*U + dely*V)/dist^2 * delx)^2 + (V - (delx*U + dely*V)/dist^2 * dely)^2),
Vdash = (delx*U + dely*V)/dist) %>%
mutate(Udash = ifelse(dist != 0, Udash, 0),
Vdash = ifelse(dist != 0, Vdash, 0)) %>%
# sign of Udash found by cross product
mutate(Udash = ifelse(delx*V - dely*U > 0) * ifelse(surf == "upper", 1, -1) * Udash)
}
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
stopCluster(parallelCluster)
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
source('C:/Users/Alwin/Documents/GitHub/MAE3401-Viper-Airfoil-Visualisation/Viper-Airfoil-Visualisation-Batch-Runs/Rough Parallel Runs.R', echo=TRUE)
stopCluster(parallelCluster)
lmesh
source("Function Install Packages.R")
LoadPackages()
source("Function Load Data.R")
NACA = 4412
airfoildata <- AirfoilData(NACA, -0.5, 1)
folderdata <- LoadFolder()
source("Thread Function Calls.R")
parallelCluster <- makeCluster(parallel::detectCores())
clusterExport(parallelCluster, c("airfoildata", "ThreadAll"))
a1 <- pblapply(
folderdata,
function(filedata) {
with(filedata, ThreadAll(ID, Re, AoA, filepath, filedata, airfoildata))},
cl = parallelCluster
)
stopCluster(parallelCluster)
